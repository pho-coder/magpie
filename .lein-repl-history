                                                                          b
                                                                          (recur (rest t1) (rest t2))))))))) versions)) suffix)))))
(import 'java.io.FilenameFilter)
(defn find-best-jar
  [path prefix suffix & {:keys [version]}]
  (if version
    (str prefix version suffix)
    (let [^File dir (File. path)
          jars (.list dir (reify FilenameFilter
                            (accept [this dir name]
                              (and (.startsWith name prefix) (.endsWith name suffix)))))
          versions (map #(clojure.string/split (subs % (count prefix) (- (count %) (count suffix))) #"\.") jars)]
      (when (and (.exists dir) jars)
        (str prefix (clojure.string/join "." (reduce (fn [a b] (let [v1 (map #(Integer/parseInt %) a)
                                                                    v2 (map #(Integer/parseInt %) b)]
                                                                (loop [t1 v1
                                                                       t2 v2]
                                                                  (if (empty? t1)
                                                                    b
                                                                    (if (empty? t2)
                                                                      a
                                                                      (if (> (first t1) (first t2))
                                                                        a
                                                                        (if (< (first t1) (first t2))
                                                                          b
                                                                          (recur (rest t1) (rest t2))))))))) versions)) suffix)))))
(find-best-jar "/tmp/avatar" "sqlserver-tracker" "-standlone.jar")
(find-best-jar "/tmp/avatar" "sqlserver-tracker" "-standalone.jar")
(defn process-running? [pid]
  (try
    (let [^Process p (launch-process (str "ps -p " pid))
          ^InputStream is (.getInputStream p)
          ^BufferedReader br (BufferedReader. (InputStreamReader. is))
          result (do (.readLine br) (.readLine br))]
      (.waitFor p)
      (.close is)
      (.close br)
      (.destroy p)
      (if result true false))
    (catch Exception e
      (wrap-in-runtime e))))
(import (defn launch-process [command & {:keys [environment] :or {environment {}}}]
  (let [command (->> (seq (.split command " "))
                     (filter (complement empty?)))
        builder (ProcessBuilder. command)
        process-env (.environment builder)]
    (doseq [[k v] environment]
      (.put process-env k v))
    (.start builder)))
)
(defn launch-process [command & {:keys [environment] :or {environment {}}}]
  (let [command (->> (seq (.split command " "))
                     (filter (complement empty?)))
        builder (ProcessBuilder. command)
        process-env (.environment builder)]
    (doseq [[k v] environment]
      (.put process-env k v))
    (.start builder)))
(defn process-running? [pid]
  (try
    (let [^Process p (launch-process (str "ps -p " pid))
          ^InputStream is (.getInputStream p)
          ^BufferedReader br (BufferedReader. (InputStreamReader. is))
          result (do (.readLine br) (.readLine br))]
      (.waitFor p)
      (.close is)
      (.close br)
      (.destroy p)
      (if result true false))
    (catch Exception e
      (wrap-in-runtime e))))
(import 'java.io.BufferedReader)
(import 'java.io.InputStreamReader)
(defn process-running? [pid]
  (try
    (let [^Process p (launch-process (str "ps -p " pid))
          ^InputStream is (.getInputStream p)
          ^BufferedReader br (BufferedReader. (InputStreamReader. is))
          result (do (.readLine br) (.readLine br))]
      (.waitFor p)
      (.close is)
      (.close br)
      (.destroy p)
      (if result true false))
    (catch Exception e
      (wrap-in-runtime e))))
(import 'java.io.InputStream)
(defn process-running? [pid]
  (try
    (let [^Process p (launch-process (str "ps -p " pid))
          ^InputStream is (.getInputStream p)
          ^BufferedReader br (BufferedReader. (InputStreamReader. is))
          result (do (.readLine br) (.readLine br))]
      (.waitFor p)
      (.close is)
      (.close br)
      (.destroy p)
      (if result true false))
    (catch Exception e
      (wrap-in-runtime e))))
(defn wrap-in-runtime
  "Wraps an exception in a RuntimeException if needed" 
  [^Exception e]
  (if (instance? RuntimeException e)
    e
    (RuntimeException. e)))
(defn process-running? [pid]
  (try
    (let [^Process p (launch-process (str "ps -p " pid))
          ^InputStream is (.getInputStream p)
          ^BufferedReader br (BufferedReader. (InputStreamReader. is))
          result (do (.readLine br) (.readLine br))]
      (.waitFor p)
      (.close is)
      (.close br)
      (.destroy p)
      (if result true false))
    (catch Exception e
      (wrap-in-runtime e))))
(process-running? 24764
)
(process-running? 24764)
(process-running? 24765)
(import 'java.lang.Redirect)
(import 'java.lang.ProcessBuilder$Redirect)
(import 'java.lang.ProcessBuilder)
(prn (Redirect/INHERIT))
(prn (ProcessBuilder$Redirect/INHERIT))
(prn (ProcessBuilder$$Redirect/INHERIT))
(import 'java.lang.ProcessBuilder$Redirect)
(import 'java.lang.ProcessBuilder.Redirect)
(import 'java.lang.ProcessBuilder$Redirect)
(import 'java.lang.ProcessBuilder.Redirect)
(import 'java.lang.ProcessBuilder$Redirect)
(.redirectOutput java.lang.ProcessBuilder$Redirect/INHERIT)
exit
(.redirectOutput java.lang.ProcessBuilder$Redirect/INHERIT)
exit
(empty? nil)
(defn get-best [a b c d]
 (if (empty? supervisors)
      nil
      (if (= (count supervisors) 1)
        [(first supervisors) (get (first supervisor-infos) "free-memory")]
        (apply (fn [a b] (if (> (second a) (second b))
                          a
                          b))
               (map (fn [s i] [s (get i "free-memory")]) supervisors supervisor-infos)))))
(defn get-best [supervisors supervisor-infos]
 (if (empty? supervisors)
      nil
      (if (= (count supervisors) 1)
        [(first supervisors) (get (first supervisor-infos) "free-memory")]
        (apply (fn [a b] (if (> (second a) (second b))
                          a
                          b))
               (map (fn [s i] [s (get i "free-memory")]) supervisors supervisor-infos)))))
(get-best ["a" "b" "c"] [{"free-memory" 1024} {"free-memory" 1024} {"free-memory" 1024}])
(defn get-best [supervisors supervisor-infos]
 (if (empty? supervisors)
      nil
      (if (= (count supervisors) 1)
        [(first supervisors) (get (first supervisor-infos) "free-memory")]
(reduce (fn [a b] (if (> (second a) (second b))
           a
           b))
(map (fn [s i] [s (get i "free-memory")]) supervisors supervisor-infos)))))
(get-best ["a" "b" "c"] [{"free-memory" 1024} {"free-memory" 1024} {"free-memory" 1024}])
(defn add-to-classpath [classpath paths]
  (clojure.string/join ":" (cons classpath paths)))
(defn get-configuration []
  (System/getProperty "avatar.configuration"))
(add-to-classpath "abc" ["def"])
exit
(require 'com.jd.magpie.util.zookeeper)
(def zk-handler (zookeeper/mk-client {} "storm1" 2181 :root "/avatar")
)
(def zk-handler (zookeeper/mk-client {} "storm1" 2181 :root "/avatar"))
(require 'com.jd.magpie.util.zookeeper :as zk)
(require 'com.jd.magpie.util.zookeeper as zk)
(require com.jd.magpie.util.zookeeper as zk)
(require 'com.jd.magpie.util.zookeeper as 'zk)
(require 'com.jd.magpie.util.zookeeper :as 'zk)
(def zk-handler (com.jd.magpie.util.zookeeper/mk-client {} "storm1" 2181 :root "/avatar"))
(def conf (com.jd.magpie.util.config/read-magpie-config))
(require 'com.jd.magpie.util.config)
(def conf (com.jd.magpie.util.config/read-magpie-config))
(require 'com.jd.magpie.util.utils)
(def conf (com.jd.magpie.util.utils/find-yaml "magpie.yaml.example"))
(def zk-handler (com.jd.magpie.util.zookeeper/mk-client conf "storm1" 2181 :root "/avatar"))
(com.jd.magpie.util.zookeeper/get-children zk-handler "/avatar" false)
(.close zk-handler)
(def zk-handler (com.jd.magpie.util.zookeeper/mk-client conf "10.12.218.191" 2181 :root "/avatar"))
(.close zk-handler)
(def zk-handler (com.jd.magpie.util.zookeeper/mk-client conf "10.12.218.191" 2181 :root "/magpie-test"))
(com.jd.magpie.util.zookeeper/get-children zk-handler "/avatar" false)
(com.jd.magpie.util.zookeeper/get-children zk-handler "/abc" false)
(.close zk-handler)
(import 'java.util.List)
(import 'java.util.ArrayList)
(def a (ArrayList.))
(.add a "a0001")
(.add a "a0002")
(.add a "a0003")
(.add a "a0004")
(.toArray a)
(import 'java.util.Arrays)
(Arrays/sorts (.toArray a))
(Arrays/sort (.toArray a))
a
(Arrays/sort a)
(def b (.toArray a))
(Arrays/sort b)
b
(.add a "a0000")
a
(def b (.toArray a))
(Arrays/sort b)
(doseq [c b] (prn c))
(def b (.toArray a))
(doseq [c b] (prn c))
exit
(defn read-file-contents [filepath]
  (if (exists-file? filepath)
    (slurp filepath)))
(defn exists-file? [path]
  (.exists (File. path)))
import 'java.io.File
(import 'java.io.File)
(defn read-file-contents [filepath]
  (if (exists-file? filepath)
    (slurp filepath)))
(defn exists-file? [path]
  (.exists (File. path)))
(read-file-contents "/tmp/abc")
(defn a (let [*uuid* (read-file-contents uuid-file)
                   new-uuid (utils/uuid)]
               (if *uuid*
                 *uuid*
                 (do (write-file-contents uuid-file new-uuid)
                     new-uuid))))
(defn a []
(let [*uuid* (read-file-contents uuid-file)
                   new-uuid (utils/uuid)]
               (if *uuid*
                 *uuid*
                 (do (write-file-contents uuid-file new-uuid)
                     new-uuid))))
(defn a [uuid-file]
(let [*uuid* (read-file-contents uuid-file)
                   new-uuid (utils/uuid)]
               (if *uuid*
                 *uuid*
                 (do (write-file-contents uuid-file new-uuid)
                     new-uuid))))
(defn a [uuid-file]
(let [*uuid* (read-file-contents uuid-file)
                   new-uuid (uuid)]
               (if *uuid*
                 *uuid*
                 (do (write-file-contents uuid-file new-uuid)
                     new-uuid))))
(defn write-file-contents [filepath contents]
  (spit filepath contents))
(defn uuid []
  (str (UUID/randomUUID)))
(import 'java.util.UUID)
(defn uuid []
  (str (UUID/randomUUID)))
(defn a [uuid-file]
(let [*uuid* (read-file-contents uuid-file)
                   new-uuid (uuid)]
               (if *uuid*
                 *uuid*
                 (do (write-file-contents uuid-file new-uuid)
                     new-uuid))))
(a "/tmp/123")
(a "/tmp/223")
(a "/tmp/123")
(a "/tmp/223")
(require '[com.jd.magpie.util.utils :as utils])
(utils/hostname)
(utils/ip)
(utils/exists-file? "/tmp/abc")
(def get-resources-url-func (fn [] (utils/bytes->string (zookeeper/get-data zk-handler (str webservice-path "/resource") false)))
)
(require '[com.jd.magpie.util.zookeeper :as zookeeper])
(def get-resources-url-func (fn [] (utils/bytes->string (zookeeper/get-data zk-handler (str webservice-path "/resource") false)))
)
(def zk-handler (zookeeper/mk-client {} "192.168.214.114" "2181" :root "/magpie-test")
）
)))
(use '[com.jd.magpie.bootstrap])
(def zk-handler (zookeeper/mk-client {MAGPIE-ZOOKEEPER-CONNECTION-TIMEOUT 15000 MAGPIE-ZOOKEEPER-SESSION-TIMEOUT 20000 MAGPIE-ZOOKEEPER-RETRY-INTERVAL 1000 MAGPIE-ZOOKEEPER-RETRY-TIMES 5 MAGPIE-ZOOKEEPER-RETRY-INTERVAL-CEILING 50000} "192.168.214.114" "2181" :root "/magpie-test")）
)
(def zk-handler (zookeeper/mk-client {MAGPIE-ZOOKEEPER-CONNECTION-TIMEOUT 15000 MAGPIE-ZOOKEEPER-SESSION-TIMEOUT 20000 MAGPIE-ZOOKEEPER-RETRY-INTERVAL 1000 MAGPIE-ZOOKEEPER-RETRY-TIMES 5 MAGPIE-ZOOKEEPER-RETRY-INTERVAL-CEILING 50000} "192.168.214.114" "2181" :root "/magpie-test"))
(def zk-handler (zookeeper/mk-client {MAGPIE-ZOOKEEPER-CONNECTION-TIMEOUT 15000 MAGPIE-ZOOKEEPER-SESSION-TIMEOUT 20000 MAGPIE-ZOOKEEPER-RETRY-INTERVAL 1000 MAGPIE-ZOOKEEPER-RETRY-TIMES 5 MAGPIE-ZOOKEEPER-RETRY-INTERVAL-CEILING 50000} ["192.168.214.114"] "2181" :root "/magpie-test"))
(zk-handler/close)
(zookeeper/close zk-handler)
(.close zk-handler)
get-resources-url-func (fn [] (utils/bytes->string (zookeeper/get-data zk-handler (str webservice-path "/resource") false)))
(def get-resources-url-func (fn [] "http://192.168.214.123:8080/magpie/"))
(defn download [url path]
  (let [contents (client/get url {:as :stream})
        ^DataInputStream dis (DataInputStream. (:body contents))
        ^FileOutputStream fos (FileOutputStream. path)
        buffer (byte-array 1024)]
    (if (= (:status contents) 200)
      (do (loop [size (.read dis buffer)]
            (when-not (= size -1)
              (.write fos buffer 0 size)
              (recur (.read dis buffer))))
          (.close dis)
          (.close fos))
      (log/error url " file not found!"))
    path))
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath))
    filepath))
(utils/find-jar "/tmp/" "magpie-mysql-parser-1.0-standalone.jar" get-resources-url-func)
(utils/find-jar "/tmp/" "magpie-mysql-parser-1.0-standalone.jarabc" get-resources-url-func)
(require '[com.jd.magpie.util.utils :as utils])
(utils/find-jar "/tmp/" "magpie-mysql-parser-1.0-standalone.jarabc" get-resources-url-func)
(defn normalize-path
  "fix the path to normalized form"
  [path]
  (let [path (if (empty? path) "/" path)
        path (if (and (.endsWith path "/") (> (count path) 1))
               (apply str (drop-last path))
               path)]
    path))
(defn exists-file? [path]
  (.exists (File. path)))
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath))
    filepath))
(import 'java.io.File)
(require '[clj-http.client :as client])
(defn exists-file? [path]
  (.exists (File. path)))
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath))
    filepath))
(import 'java.io.DataInputStream)
(import 'java.io.FileOutputStream)
(defn exists-file? [path]
  (.exists (File. path)))
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath))
    filepath))
(require '[clojure.tools.logging :as log])
(defn exists-file? [path]
  (.exists (File. path)))
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath))
    filepath))
(find-jar "/tmp/" "magpie-mysql-parser-1.0-standalone.jarabc" get-resources-url-func)
(defn find-jar [jars-dir jar get-resources-url-func]
  (let [filepath (normalize-path (str jars-dir "/" jar))]
    (if-not (exists-file? filepath)
      (try 
        (download (normalize-path (str (get-resources-url-func) "/" jar)) filepath)
        (catch Exception e
          (log/info "error accurs in downloading jar, exception:" e))))
    filepath))
(find-jar "/tmp/" "magpie-mysql-parser-1.0-standalone.jarabc" get-resources-url-func)
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (log/info (:status contents))
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(download "http://192.168.214.123:8080/magpie/magpie-mysql-parser-1.0-standalone.jarabc" "/tmp/")
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (prn (:status contents))
    (if (= (:status contents) 200)
      (let [^DataInputStream dis (DataInputStream. (:body contents))
            ^FileOutputStream fos (FileOutputStream. path)
            buffer (byte-array 1024)]
        (loop [size (.read dis buffer)]
          (when-not (= size -1)
            (.write fos buffer 0 size)
            (recur (.read dis buffer))))
        (.close dis)
        (.close fos))
      (log/error url " file not found!"))
    path))
(download "http://192.168.214.123:8080/magpie/magpie-mysql-parser-1.0-standalone.jarabc" "/tmp/")
(defn download [url path]
  (let [contents (client/get url {:as :stream})]
    (prn contents)
    
    (prn (:status contents))
    ;; (if (= (:status contents) 200)
    ;;   (let [^DataInputStream dis (DataInputStream. (:body contents))
    ;;         ^FileOutputStream fos (FileOutputStream. path)
    ;;         buffer (byte-array 1024)]
    ;;     (loop [size (.read dis buffer)]
    ;;       (when-not (= size -1)
    ;;         (.write fos buffer 0 size)
    ;;         (recur (.read dis buffer))))
    ;;     (.close dis)
    ;;     (.close fos))
    ;;   (log/error url " file not found!"))
    path))
(download "http://192.168.214.123:8080/magpie/magpie-mysql-parser-1.0-standalone.jarabc" "/tmp/")
a
exit
(require '[com.jd.magpie.util.utils :as utils])
(utils/local-mkdirs "/tmp/a")
(utils/local-mkdirs "/tmp/b/d")
(def a "dfdf")
(.startswith a "d")
(.startwith a "d")
(.startsWith a "d")
(def b nil)
(.startsWith b "d")
b
(nil? b)
quit
(require '[com.jd.magpie.util.utils :as utils])
(utils/local-mkdirs "/tmp/a/b")
quit
exit;
